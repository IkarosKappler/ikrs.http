package ikrs.http.resource;

/**
 * @author  Ikaros Kappler
 * @date    2012-07-20
 * @version 1.0.0
 **/

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URI;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock; 


import ikrs.http.HTTPFileFilter;
import ikrs.http.ReadOnlyException;
import ikrs.http.Resource;
import ikrs.util.CaseInsensitiveComparator;
import ikrs.util.CustomLogger;
import ikrs.util.MIMEType;


public abstract class AbstractDirectoryResource
    extends AbstractResource
    implements Resource {

    
    private File dir;
    private URI requestURI;
    private String outputFormat;

    private ByteArrayInputStream inputStream;
    private long length;

    private DateFormat dateFormat;

    private HTTPFileFilter fileFilter;
    
    /**
     * Create a new FileResource.
     *
     * @param dir        The directory.
     * @param requestURI The uri from the request (will be used to avoid printing the absolute file path).
     * @param format     The desired output format: HTML or TXT (default).
     * @param useFairLocks
     **/
    public DirectoryResource( CustomLogger logger,
			      HTTPFileFilter fileFilter,
			      File dir,
			      URI requestURI,
			      String format,
			      boolean useFairLocks ) 
	throws NullPointerException {

	super( logger, useFairLocks );

	if( dir == null )
	    throw new NullPointerException( "Cannot create DirectoryResource with null-directory." );
       
	if( requestURI == null )
	    throw new NullPointerException( "Cannot create DirectoryResource with null-URI." );

	//if( !dir.isDirectory() )
	//    throw new IOException( "Cannot create DirectoryResource with a non-directory file ('" + dir.getPath() +"')." );

	this.fileFilter   = fileFilter;
	this.dir          = dir;
	this.requestURI   = requestURI;
	this.outputFormat = format;

	this.dateFormat   = new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" );
    }


    //---BEGIN------------------- AbstractResource implementation ----------------------------
    /**
     * This method determines if this resource was alerady opened or not.
     *
     * @throws IOException If any IO error occurs.
     **/
    public boolean isOpen()
	throws IOException {

	return (this.inputStream != null);
	
    }


    /**
     * This method opens the underlying resource. Don't forget to close.
     *
     * @param readOnly if set to true, the resource will be opned in read-only mode.
     *
     * @throws ReadOnlyException If the underlying resource is read-only in general.
     * @throws IOException If any other IO error occurs.
     * @see isReadOnly()
     **/
    public void open( boolean readOnly )
	throws ReadOnlyException,
	       IOException {


	if( !readOnly )
	    throw new ReadOnlyException( "This DirectoryResource implementation only supports read-only access at the moment." );

	if( this.inputStream != null ) 	    
	    throw new IOException( "Cannot re-open DirectoryResource; it's already open." );

	if( !this.dir.isDirectory() ) 
	    throw new IOException( "Cannot open DirectoryResource; file '"+this.requestURI.getPath()+"' is not a directory." );


	
	// Print the directory listing into a buffer!
	getLogger().log( Level.INFO,
			 getClass().getName() + ".open(...)",
			 "Going to generate directory listing for '"+this.requestURI.getPath()+"'." );

	ByteArrayOutputStream out = new ByteArrayOutputStream( 1024 );
	String title = "Files in " + this.requestURI.getPath() + getFormattedLineBreak(2);

	if( this.isHTMLFormat() ) {

	    String htmlHeader = 
		"<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" +
		"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \n" + 
		"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n" +
		"<html xmlns=\"http://www.w3.org/1999/xhtml\">\n" +
		"<head>\n" + 
		"<title>Contents of " + this.requestURI.getPath() + "</title>\n" +
		"<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/x-icon\" />\n" + 
		"</head>\n" + 
		"\n" + 
		"<body>\n" + 
		"\n" + 
		"<h2>" + title + "</h2>\n" +
		"\n"; // +
	    // "<table border=\"1\">\n";
		
	    out.write( htmlHeader.getBytes() );
	    
	} else {
 
	    out.write( title.getBytes() );

	}



	// First make the '..' navigation file (if parent exists)
	if( this.isHTMLFormat() && !this.requestURI.getPath().equals("/") ) {
	    
	    String parentPath = new File(this.requestURI.getPath()).getParent();
	    String parentLink = "<a href=\"" + parentPath + "\">parent dir</a><br/><br/>\n";
	    out.write( parentLink.getBytes() );

	}

	if( this.isHTMLFormat() ) {
	 
	    String tableStart = "<table border=\"0\">\n";
	    out.write( tableStart.getBytes() );
	    
	}


	// Write temp file data into buffer
	StringBuffer lineBuffer = new StringBuffer();


	File[] files = dir.listFiles();

	files = sortFiles( files );

	for( int i = 0; i < files.length; i++ ) {
	    
	    //if( files[i].getName().equalsIgnoreCase(".htaccess") 
	    //	|| files[i].getName().equalsIgnoreCase(".htpasswd") )
	    if( !this.fileFilter.acceptListing(files[i]) )
		continue;  // Hide due to security reasons

	    buildLine( lineBuffer, files[i] );
	    out.write( lineBuffer.toString().getBytes() );
	    lineBuffer.delete( 0, lineBuffer.length() );
    
	}

	String footLine = 		
	    getFormattedLineBreak(2) +
	    "Generated contents" +
	    getFormattedLineBreak();
	
	if( this.isHTMLFormat() ) {

	    String htmlFooter =
		"</table>\n" +
		footLine + 
		"</body>\n" +
		"</html>\n";
	    out.write( htmlFooter.getBytes() );

	} else {

	    out.write( footLine.getBytes() );
	    
	}
	

	// This initializes the input stream!
	byte[] rawData = out.toByteArray();
	this.inputStream = new ByteArrayInputStream( rawData );
	this.length = rawData.length;
	
    }

    /**
     * This method returns true if the underlying resource is read-only (in general).
     *
     * @throws IOException If any IO error occurs.
     **/
    public boolean isReadOnly()
	throws IOException {
	
	// Byte-array resource might be writable in the future ...
	return true;
    }

    /**
     * This method returns the *actual* length of the underlying resource. This length will
     * be used in the HTTP header fields to specify the transaction length.
     *
     * During read-process (you used the locks, didn't you?) the length MUST NOT change.
     *
     * @return the length of the resource's data in bytes.
     * @throws IOException If any IO error occurs.
     **/
    public long getLength()
	throws IOException {

	if( this.inputStream == null )
	    throw new IOException( "Cannot determine the length of an un-opened resource." );

	return this.length;
    }


    /**
     * Get the output stream to this resource.
     *
     * @throws ReadOnlyException If this resource was opened with the read-only flag set.
     * @throws IOException If any other IO error occurs.
     **/
    public OutputStream getOutputStream()
	throws ReadOnlyException,
	       IOException {

	throw new ReadOnlyException( "This DirectoryResource implementation only supports read-only access at the moment." );

    }

    /**
     * Get the input stream from this resource.
     *
     * @throws IOException If any IO error occurs.
     **/
    public InputStream getInputStream()
	throws IOException {

	if( this.inputStream == null )
	    throw new IOException( "Cannot return an input stream from an un-opened resource." );

	return this.inputStream;
    }


    /**
     * Closes this resource.
     *
     * @return false if the resource was already closed, false otherwise.
     **/
    public boolean close()
	throws IOException {

	if( this.inputStream == null )
	    return false;
	
	this.inputStream = null;
	
	return true;
    }
    //---END--------------------- AbstractResource implementation ----------------------------

    private void buildLine( StringBuffer lineBuffer,
			    File file ) {

	if( this.isHTMLFormat() ) 
	    lineBuffer.append( "<tr>\n" );

	    
	for( int i = 0; i < 3; i++ ) {
	    
	    if( this.isHTMLFormat() )
		lineBuffer.append( "      <td>" );
	    else
		lineBuffer.append( "\t" );
	    

	    lineBuffer.append( getFileAttribute(file, i) );


	    if( this.isHTMLFormat() )
		lineBuffer.append( "</td>\n" );
	    
	}


	if( this.isHTMLFormat() )
	    lineBuffer.append( "</tr>\n\n" );
	else
	    lineBuffer.append( "<br/>\n" );

    }

    private String getFileAttribute( File file,
				     int field
				     ) {

		
	switch( field ) {
	case 0: 
	    if( this.requestURI.getPath() == null || this.requestURI.getPath().equals("/") )
		return "<a href=\"" + file.getName() + "\">" + file.getName() + "</a>";
	    else
		return "<a href=\"" + (this.requestURI.getPath() + "/") + file.getName() + "\">" + file.getName() + "</a>";
	    
	case 1:   
	    return Long.toString(file.length()) + " bytes";

	default:  
	    long timeStamp = file.lastModified();
	    Date date = new Date( timeStamp );
	    return this.dateFormat.format( date ); //return Long.toString(file.lastModified());  
	}

    }

    private String getFormattedLineBreak( int count ) {
	String buffer = "";
	while( count > 0 ) {

	    buffer += getFormattedLineBreak();

	    count--;
	}
	return buffer;
    }

    private String getFormattedLineBreak() {
	if( this.isHTMLFormat() ) 
	    return "<br/>\n";
	else
	    return "\n";
    }

    private boolean isHTMLFormat() {
	return (this.outputFormat != null && this.outputFormat.equalsIgnoreCase("HTML"));
    }


    private File[] sortFiles( File[] files ) {

	TreeMap<String,File> dirMap = new TreeMap<String,File>( CaseInsensitiveComparator.sharedInstance );
	TreeMap<String,File> fileMap = new TreeMap<String,File>( CaseInsensitiveComparator.sharedInstance );
 
	for( int i = 0; i < files.length; i++ ) {

	    if( files[i].isDirectory() )
		dirMap.put( files[i].getName(), files[i] );
	    else
		fileMap.put( files[i].getName(), files[i] );

	}

	int i = 0;
	Iterator<String> dirIter = dirMap.keySet().iterator();
	while( dirIter.hasNext() ) {
	    files[i++] = dirMap.get( dirIter.next() );
	}

	Iterator<String> fileIter = fileMap.keySet().iterator();
	while( fileIter.hasNext() ) {
	    files[i++] = fileMap.get( fileIter.next() );
	}


	return files;
    }

}
