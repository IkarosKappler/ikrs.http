package ikrs.yuccasrv.ui;

import java.net.Socket;
import java.net.DatagramSocket;
import javax.swing.table.AbstractTableModel;
import java.util.ArrayList;
import java.text.Collator;
import java.util.TreeMap;
import java.util.Map;
import java.util.UUID;

import ikrs.typesystem.*;
import ikrs.yuccasrv.Constants;
import ikrs.yuccasrv.socketmngr.*;

public class ServerSocketTableModel 
    extends AbstractTableModel 
    implements BindListener {
    
    private String[] columnNames = { "ID", "Address", "Port", "Protocol" };
    
    //private ArrayList<ServerSocketThread> rows;
    private ArrayList<Map<String,BasicType>> rows;

    public ServerSocketTableModel() {
	super();

	//this.rows = new ArrayList<ServerSocketThread>( 2 );
	this.rows = new ArrayList<Map<String,BasicType>>(2);
    }

    protected Map<String,BasicType> getRow( int row ) {
	return this.rows.get(row);
    }

    //---START-------------------------- BindManager ----------------------------
    /**
     * @param source The BindManager that reports the event.
     * @param socketID A unique ID to identify the created socket by the use of
     *                 BindManager.getServer*( socketID ).
     **/
    public void serverCreated( BindManager source,
			       UUID socketID ) {

	/*Collator caseInsensitive = Collator.getInstance();
	caseInsensitive.setStrength( Collator.PRIMARY );
	Map<String,BasicType> map = new TreeMap<String,BasicType>( caseInsensitive );
	map.put( "ID",                                new BasicUUIDType(socketID) );
	map.put( Constants.CONFIG_SERVER_ADDRESS,     source.getServerSettings(Constants.CONFIG_SERVER_ADDRESS) );
	map.put( Constants.CONFIG_SERVER_PORT,        new BasicStringType(Constants.CONFIG_SERVER_PORT) );
	map.put( Constants.CONFIG_SERVER_PROTOCOL,    source.getServerSettings(socketID).get(Constants.CONFIG_SERVER_PROTOCOL) );

	this.rows.add( map ); */

	this.rows.add( source.getServerSettings(socketID) );

	fireTableRowsInserted( this.rows.size()-1, this.rows.size()-1 );
    }
    

    /**
     * @param source The BindManager that reports the event.
     * @param socketID The server's unique ID.
     * @param e The reported exception.
     * @param isTraumatic This flag tell if the server socket can still
     *                    be used or if it's (probably) broken and should be
     *                    restarted. In the second case the BindManager will
     *                    automatically close and remove the socket to free
     *                    the resources.
     **/
    public void serverError( BindManager source,
			     UUID socketID,
			     Exception e,
			     boolean isTraumatic ) {

    }


    /**
     * @param source The BindManager that reports the event.
     * @param sock The accepted connection socket.
     **/
    public void serverAcceptedTCPConnection( BindManager source,
					     Socket sock ) {

    }

    /**
     * @param source The BindManager that reports the event.
     * @param sock The accepted connection socket.
     **/
    public void serverAcceptedUDPConnection( BindManager source,
					     DatagramSocket sock ) {

    }

    
    /**
     * @param source The BindManager that reports the event.
     * @param sockedID The server socket's unique ID.
     **/
    public void serverClosed( BindManager source,
			      UUID socketID ) {

    }
    //---START-------------------------- BindManager ----------------------------

    /*public Class<?> getColumnClass( int columnIndex ) {

      }*/

    public String getColumnName( int column ) {
	return this.columnNames[ column ];
    }


    public int getRowCount() {
	return this.rows.size();
    }

    public int getColumnCount() {
	return this.columnNames.length;
    }

    public Object getValueAt( int row, int column ) {
	Map<String,BasicType> t = this.rows.get( row );

	switch( column ) {
	case 0:	return t.get("ID"); 
	case 1: return t.get(Constants.CONFIG_SERVER_ADDRESS); 
	case 2: return t.get(Constants.CONFIG_SERVER_PORT); 
	case 3: return t.get(Constants.CONFIG_SERVER_PROTOCOL); 
	default: return "NA"; 
	}
    }



}